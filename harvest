#!/usr/bin/env zsh

# Harvest is a short and fast script to sort what is a video or audio
# or other types over LARGE quantity of data randomically collected,
# just like torrent files downloaded from the Interwebz.
# Processes 1TB in 15 seconds average on a ZFS filesystem.

# Copyright (C) 2014-2017 Dyne.org Foundation

# Harvest is designed, written and maintained by Denis Roio <jaromil@dyne.org>

# This source code is free software; you can redistribute it and/or
# modify it under the terms of the GNU Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This source code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Please refer
# to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to: Free Software Foundation, Inc.,
# 675 Mass Ave, Cambridge, MA 02139, USA.

harvest_version=0.3
harvest_release_date="Jan/2017"

# export HARVEST_PREFIX=$HOME/devel/harvest
R=${HARVEST_PREFIX:-/usr/local/share/harvest}

DEBUG=${DEBUG:-0}

source $R/zuper/zuper

vars+=(files numfiles dirs)
vars+=(ext video_factor image_factor audio_factor code_factor text_factor other_factor)

arrs+=(alldirs)

maps+=(video audio code text image other)
maps+=(totals)

source $R/zuper/zuper.init

# source the generated code parser from file-extension-list
source $R/file-extension-list/render/file-extension-parser.zsh

# fuzzy thresholds
#
# this is the most important section to tune the selection
video_factor=1  #  minimum video files to increase the video factor
audio_factor=4  #  minimum audio files to increase the audio factor
text_factor=8   #  minimum text  files to increase the text factor
image_factor=10 #  minimum image files to increase the image factor
other_factor=20 #  minimum other files to increase the other factor
code_factor=5   #  minimum code  files to increase the code factor

notice "Harvest $harvest_version - a tool to classify large collections of files and directories"

# counts all totals using a basic fuzzy logic algo and prints results
fuzzycount() {
    fn fuzzycount $*
    arg=$1
    req=(arg)
    ckreq || return 1

    # this redefines the priority order
    choice=(video audio text image code other)

    # succesful match means an entry is greater than all others
    match=$(( ${#choice} - 1 ))

    # reset totals
    totals[video]=0
    totals[audio]=0
    totals[other]=0
    totals[image]=0
    totals[code]=0
    totals[text]=0

    [[ "$video[$arg]" = "" ]] && video[$arg]=0
    [[ "$audio[$arg]" = "" ]] && audio[$arg]=0
    [[ "$other[$arg]" = "" ]] && other[$arg]=0
    [[ "$image[$arg]" = "" ]] && image[$arg]=0
    [[ "$code[$arg]"  = "" ]] &&  code[$arg]=0
    [[ "$text[$arg]"  = "" ]] &&  text[$arg]=0

    # compute a very, very simple linear fuzzy logic for each
    (( ${#video} )) && totals[video]=$(( $video[$arg] / $video_factor ))
    (( ${#audio} )) && totals[audio]=$(( $audio[$arg] / $audio_factor ))
    (( ${#other} )) && totals[other]=$(( $other[$arg] / $other_factor ))
    (( ${#image} )) && totals[image]=$(( $image[$arg] / $image_factor ))
    (( ${#code}  )) &&  totals[code]=$((  $code[$arg] / $code_factor  ))
    (( ${#text}  )) &&  totals[text]=$((  $text[$arg] / $text_factor  ))

    for t in $choice; do
        count=0
        for o in ${(k)totals}; do
            # don't compare with self
            [[ "$t" = "$o" ]] && continue

            (( ${totals[$t]} > ${totals[$o]} )) && (( count++ ))
        done
        (( $count == $match )) && {
			# print out directories here 
			year=`stat -c %y $arg | cut -d'-' -f1`
			print "dir,$t,$year,$arg"
			return 0 }
    done

    func "unknown: $arg"
    return 1
}

analyse_files() {
	act "analysing files "
	prev=""
	numfiles=0
	for i in ${(f)1}; do
		[[ -r "$i" ]] || continue
		mime=`file-extension-parser $i`
		year=`stat -c %y $i | cut -d'-' -f1`
		files+="file,$mime,$year,$i\n"
		(print -n "." 1>&2)
		numfiles=$(( $numfiles + 1 ))
	done
}
analyse_dirs() {
	prev=""
	for i in ${(f)1}; do

		mime=`file-extension-parser $i`

		# pathname="${i##*${incoming}}"
		# base="${patnameh%%/*}"
		base=$2
		func "$mime \t $base"

		[[ "$base" = "" ]] && continue;

		case "$mime" in

			video) (( ++video[$base] )) ;;

			audio) (( ++audio[$base] )) ;;

			image) (( ++image[$base] )) ;;

			code)  (( ++code[$base] ))  ;;

			text)  (( ++text[$base] ))  ;;

			*)     (( ++other[$base] ))
				   # func "${(r:5:)other[$base]} other :: $base"
				   ;;

		esac

		[[ "$prev" = "$base" ]] || {
			(print -n "." 1>&2)
			prev="$base" }
		alldirs+=($base)
	done
}

# return here if sourcing as lib
[[ "$1" == "source" ]] && {
	zuper.exit
	return 0
}

# main argument: harvest will parse all filenames found in incoming
incoming="${1:-`pwd`}"

# TODO: build proper argument parsing and useful options
#       -e to exclude path string patterns from analysis

if   [[ "$incoming" = "source" ]]; then
    act "internal functions loaded"
    return 0

elif [[ -d "$incoming" ]]; then
    incoming=${incoming}/
	mkdir -p $HOME/.cache
	rm -f $HOME/.cache/harvest
    act   "scanning directory: $incoming"
	# TODO: make depth configurable
	analyse_files "`find $incoming -maxdepth 1 | tail -n +2`"
	print
	act "analysing directories "
	for d in ${(f)"$(find $incoming -maxdepth 1 -type d | tail -n +2)"}; do
		analyse_dirs "`find $d -maxdepth 2`" $d
	done
	print

elif [[ "$incoming" == "cache" ]]; then
	if [[ -r $HOME/.cache/harvest ]]; then
		act   "loading file list from cache"
		cat $HOME/.cache/harvest
		return 0
	else
		error "cache not found: $HOME/.cache/harvest"
		return 1
	fi
else
    error "invalid argument:   $incoming"
    return 1
fi

print
print "${files}" | /usr/bin/tee -a $HOME/.cache/harvest
for o in $alldirs; do
    fuzzycount "$o"  | /usr/bin/tee -a $HOME/.cache/harvest
done
notice "${numfiles} files and ${#alldirs} directories analysed in total"
act   "results saved, use 'harvest cache' to replay on stdout"

zuper.exit
