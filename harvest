#!/usr/bin/env zsh

# Harvest is a short and fast script to sort what is a video or audio
# or other types over LARGE quantity of data randomically collected,
# just like torrent files downloaded from the Interwebz.
# Processes 1TB in 15 seconds average on a ZFS filesystem.

# Copyright (C) 2014-2017 Dyne.org Foundation

# Harvest is designed, written and maintained by Denis Roio <jaromil@dyne.org>

# This source code is free software; you can redistribute it and/or
# modify it under the terms of the GNU Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This source code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Please refer
# to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to: Free Software Foundation, Inc.,
# 675 Mass Ave, Cambridge, MA 02139, USA.

# fuzzy thresholds
#
# this is the most important section to tune the selection

harvest_version=0.3
harvest_release_date="Jan/2017"

# export HARVEST_PREFIX
R=${HARVEST_PREFIX:-/usr/local/share/harvest}

DEBUG=${DEBUG:-0}

source zuper/zuper

vars+=(ext video_factor audio_factor code_factor text_factor other_factor)

arrs+=(all)

maps+=(video audio code text other)
maps+=(totals)

source zuper/zuper.init

# source the generated code parser from file-extension-list
source file-extension-list/render/file-extension-parser.zsh

video_factor=1  #  minimum video files to increase the video factor
audio_factor=4  #  minimum audio files to increase the audio factor
text_factor=8   #  minimum text  files to increase the text factor
other_factor=20 #  minimum other files to increase the other factor
code_factor=5   #  minimum code  files to increase the code factor

notice "Harvest $harvest_version - a tool to classify large collections of files and directories"

# counts all totals using a basic fuzzy logic algo and prints results
fuzzycount() {
	fn fuzzycount $*
	arg=$1
	req=(arg)
	ckreq || return 1

	# this redefines the priority order
	choice=(text video audio code other)

	# succesful match means an entry is greater than all others
	match=$(( ${#choice} - 1 ))

	# reset totals
	totals[video]=0
	totals[audio]=0
	totals[other]=0
	totals[code]=0
	totals[text]=0

    [[ "$video[$arg]" = "" ]] && video[$arg]=0
    [[ "$audio[$arg]" = "" ]] && audio[$arg]=0
    [[ "$other[$arg]" = "" ]] && other[$arg]=0
	[[ "$code[$arg]"  = "" ]] &&  code[$arg]=0
	[[ "$text[$arg]"  = "" ]] &&  text[$arg]=0

    # very very simple, linear fuzzy logic for each
    (( ${#video} )) && totals[video]=$(( $video[$arg] / $video_factor ))
    (( ${#audio} )) && totals[audio]=$(( $audio[$arg] / $audio_factor ))
    (( ${#other} )) && totals[other]=$(( $other[$arg] / $other_factor ))
	(( ${#code}  )) && totals[code]=$((  $code[$arg]  / $code_factor  ))
	(( ${#text}  )) && totals[text]=$((  $text[$arg]  / $text_factor  ))

	for t in $choice; do
		count=0
		for o in ${(k)totals}; do
			# don't compare with self
			[[ "$t" = "$o" ]] && continue

			(( ${totals[$t]} > ${totals[$o]} )) && (( count++ ))
		done
		(( $count == $match )) && { print "$t: $arg"; return 0 }
	done

	func "unknown: $arg"
	return 1
}

# sort all filetypes in incoming, move non-videos away
incoming="${1:-`pwd`}" #/var/lib/transmission/downloads/

# TODO: build proper argument parsing and useful options
#       -e to exclude path string patterns from analysis

if   [[ "$incoming" = "source" ]]; then
	act "internal functions loaded"
	return 0

elif [[ -d "$incoming" ]]; then
	incoming=${incoming}/
	act   "scanning directory: $incoming"
	files=`find $incoming`

elif [[ -r "$incoming" ]]; then
	act   "loading file list:  $incoming"
	files=`cat $1`

else
	error "invalid argument:   $incoming"
	return 1
fi
	
act -n "analysing files "
prev=""
for i in ${(f)files}; do

    mime=`file-extension-parser $i`
	func "$mime \t $i"

    path="${i##*${incoming}}"
    base="${path%%/*}"
	[[ "$base" = "" ]] && continue;

    case "$mime" in

		video) (( ++video[$base] ))
			   ;;

		audio) (( ++audio[$base] ))
			   ;;

		code)  (( ++code[$base] ))
			   ;;

		text)  (( ++text[$base] ))
			   ;;

		*)     (( ++other[$base] ))
			   # func "${(r:5:)other[$base]} other :: $base"
			   ;;

    esac

	[[ "$prev" = "$base" ]] || {
		(print -n "." 1>&2)
		prev="$base" }
		all+=($base)
done

print
notice "${#all} base directories analysed. Results below"
for o in $all; do

	fuzzycount "$o"

done

zuper.exit
